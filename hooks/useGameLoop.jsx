/**
 * This code was pregenerated by Claude, given game.jsx, then largely refactored
 */

// hooks/useGameLoop.js
import { useState, useEffect, useRef, useCallback } from 'react';
import Player from '@modules/game/Player';
import Projectile from '@modules/game/Projectile';
import { EnemySpawner } from '@modules/game/EnemySpawner';
import { CollisionDetector } from '@modules/game/CollisionDetector';

const PLAYER_START_HP = 10;
// const PLAYER = new Player(SCREEN_WIDTH - 100, SCREEN_HEIGHT / 2, PLAYER_START_HP);

export function useGameLoop({ width, height, offsetX = 0, offsetY = 0 }) {
    // ... (state init)

    const [gameState, setGameState] = useState({
        projectiles: [], // List of projectiles
        enemies: [], // List of enemies
        paused: false, // Pause game indicator
    });

    const playerRef = useRef(null);
    if (!playerRef.current) {
        playerRef.current = new Player(
            width - 100,
            height / 2,
            PLAYER_START_HP,
            50,
            50,
            { x: 0, y: 0 }, // Image Offset
            { x: 30, y: 15 } // Spawn Offset - Adjusted to match weapon position
        );
    }
    const enemySpawnerRef = useRef(null);
    const fireIntervalRef = useRef(null);
    const startTimeRef = useRef(Date.now());

    // Generate a path for the level
    const generateComplexPath = (startX, startY, turns) => {
        let path = [{ x: startX, y: startY }];
        let currentX = startX;
        let currentY = startY;
        const segmentWidth = width / (turns + 1);

        for (let i = 0; i < turns; i++) {
            // Move forward
            currentX += segmentWidth;
            // Random Y within bounds (padding 50)
            currentY = Math.random() * (height - 100) + 50;
            path.push({ x: currentX, y: currentY });
        }

        // Final point off screen
        path.push({ x: width + 100, y: currentY });
        return path;
    };

    const levelPathRef = useRef(null);

    // Execute when loaded
    useEffect(() => {
        // Generate the path once
        // Default start at random Y on left side if not specified (though we use 0,0 mostly for offscreen spawn)
        let startY = Math.random() * (height - 100);
        levelPathRef.current = generateComplexPath(0, startY, 5);

        // Initialize the EnemySpawner
        enemySpawnerRef.current = new EnemySpawner(height, (enemy) => {
            // Apply the path
            if (levelPathRef.current) {
                enemy.setPath(levelPathRef.current);
                // Set initial position to start of path
                enemy.x = levelPathRef.current[0].x;
                enemy.y = levelPathRef.current[0].y;
            } else {
                // Fallback
                enemy.y = Math.random() * (height - 100);
            }

            // Include the previous gamestate, but overwrite 'enemies' to add the spawned enemy
            setGameState((prev) => ({
                ...prev,
                enemies: [...prev.enemies, enemy],
            }));
        });

        // Enable enemy spawning
        enemySpawnerRef.current.start();

        return () => {
            // Execute this when the game is closed
            // Stop enemies and projectiles from spawning
            enemySpawnerRef.current.stop();
            if (fireIntervalRef.current) {
                clearInterval(fireIntervalRef.current);
            }
        };
    }, []);

    // Handle pause/unpause
    useEffect(() => {
        if (gameState.paused) {
            // The game is paused
            // Prevent enemy and projectile spawning
            enemySpawnerRef.current?.stop();
            if (fireIntervalRef.current) {
                clearInterval(fireIntervalRef.current);
                fireIntervalRef.current = null;
            }
        } else {
            // The game was resumed
            // Resume enemy spawning
            enemySpawnerRef.current?.start();
        }
    }, [gameState.paused]);

    /**
     * Fire a projectile from the player's location
     */
    const fireProjectile = useCallback(() => {
        const player = playerRef.current;
        const { x, y } = player.getProjectileSpawnLocation();

        const projectile = new Projectile(x, y, player.rotation);

        setGameState((prev) => ({
            ...prev,
            projectiles: [...prev.projectiles, projectile],
        }));
    }, []);

    /**
     * Process touch inputs. Determines player & projectile angle.
     */
    const handleTouch = useCallback(
        (touches) => {
            // Quit if the game is paused
            if (gameState.paused) return;

            // Determine the touch input statistics
            const start = touches.find((t) => t.type === 'start');
            const end = touches.find((t) => t.type === 'end');
            const press = touches.find((t) => t.type === 'press');
            const touch = touches.find((t) => t.type === 'start' || t.type === 'move');

            // Handle firing
            if (start) {
                // When held down, fire at an interval
                // Only start if not already firing to prevent duplicates/sticking
                if (!fireIntervalRef.current) {
                    fireIntervalRef.current = setInterval(fireProjectile, 100);
                }
            }
            if (press) {
                // When pressed, fire once
                fireProjectile();
            }
            // When the touch ends, stop firing
            if (end && fireIntervalRef.current) {
                clearInterval(fireIntervalRef.current);
                fireIntervalRef.current = null;
            }

            // Handle player rotation
            if (touch) {
                const player = playerRef.current;
                // Touch location
                const touchX = touch.event.pageX - offsetX;
                const touchY = touch.event.pageY - offsetY;
                // Distance between player & touch
                const dx = touchX - player.x;
                const dy = touchY - player.y;
                // Distance angle, update player rotation
                const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                player.rotation = angle;
            }
        },
        [gameState.paused, fireProjectile, offsetX, offsetY]
    );

    /**
     * Update the game/render state
     */
    const updateGame = useCallback(() => {
        // Quit if the game is paused or player is dead
        if (gameState.paused || playerRef.current.getHp() <= 0) return;

        // Update the game state on each execution
        setGameState((prev) => {
            // Update all entities
            const updatedProjectiles = prev.projectiles.map((p) => {
                p.update();
                return p;
            });
            const updatedEnemies = prev.enemies.map((e) => {
                e.update();
                return e;
            });

            // Check collisions
            const scoreGained = CollisionDetector.checkProjectileEnemyCollisions(updatedProjectiles, updatedEnemies);

            // Filter active entities
            const { activeProjectiles, activeEnemies } = CollisionDetector.filterActiveEntities(updatedProjectiles, updatedEnemies, width, height);

            // Check if enemies escaped
            activeEnemies.forEach((e) => {
                let outOfBounds = playerRef.current.enemyOutOfBounds(e);

                // The enemy passed the player
                if (outOfBounds) {
                    // Apply damage to the player
                    playerRef.current.takeDamage(e.getDamage());

                    // Disable the enemy
                    e.active = false;
                }
            });

            // Increment the player's score
            if (playerRef.current) playerRef.current.addScore(scoreGained);

            return {
                ...prev,
                projectiles: activeProjectiles,
                enemies: activeEnemies,
            };
        });
    }, [gameState.paused]);

    // Pause/Unpause the game
    const togglePause = useCallback(() => {
        setGameState((prev) => ({ ...prev, paused: !prev.paused }));
    }, []);

    // Gameplay duration
    const getGameDuration = useCallback(() => {
        return Date.now() - startTimeRef.current;
    }, []);

    // Make game-loop data available to components
    return {
        gameState,
        player: playerRef.current,
        handleTouch,
        updateGame,
        togglePause,
        getGameDuration,
        isGameOver: playerRef.current.getHp() <= 0,
    };
}
