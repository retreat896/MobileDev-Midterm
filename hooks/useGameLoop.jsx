/**
 * This code was pregenerated by Claude, given game.jsx, then largely refactored
 */

// hooks/useGameLoop.js
import { useState, useEffect, useRef, useCallback } from 'react';
import { Dimensions } from 'react-native';
import Player from '@modules/game/Player';
import Projectile from '@modules/game/Projectile';
import { EnemySpawner } from '@modules/game/EnemySpawner';
import { CollisionDetector } from '@modules/game/CollisionDetector';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('screen');

const PLAYER_START_HP = 100;
const PLAYER = new Player(SCREEN_WIDTH - 100, SCREEN_HEIGHT / 2, PLAYER_START_HP);

export function useGameLoop() {
	const [gameState, setGameState] = useState({
		projectiles: [],	// List of projectiles
		enemies: [],		// List of enemies
		paused: false,		// Pause game indicator
	});

	const playerRef = useRef(PLAYER);
	const enemySpawnerRef = useRef(null);
	const fireIntervalRef = useRef(null);
	const startTimeRef = useRef(Date.now());

	// Execute when loaded
	useEffect(() => {
		// Initialize the EnemySpawner
		enemySpawnerRef.current = new EnemySpawner(SCREEN_HEIGHT, (enemy) => {
			// Include the previous gamestate, but overwrite 'enemies' to add the spawned enemy 
			setGameState(prev => ({
				...prev,
				enemies: [...prev.enemies, enemy]
			}));
		});

		// Enable enemy spawning
		enemySpawnerRef.current.start();

		return () => { // Execute this when the game is closed
			// Stop enemies and projectiles from spawning
			enemySpawnerRef.current.stop();
			if (fireIntervalRef.current) {
				clearInterval(fireIntervalRef.current);
			}
		};
	}, []);

	// Handle pause/unpause
	useEffect(() => {
		if (gameState.paused) { // The game is paused
			// Prevent enemy and projectile spawning
			enemySpawnerRef.current?.stop();
			if (fireIntervalRef.current) {
				clearInterval(fireIntervalRef.current);
				fireIntervalRef.current = null;
			}
		}
		else { // The game was resumed
			// Resume enemy spawning
			enemySpawnerRef.current?.start();
		}
	}, [gameState.paused]);

	/**
	 * Fire a projectile from the player's location
	 */
	const fireProjectile = useCallback(() => {
		const player = playerRef.current;
		const projectile = new Projectile(
			player.x,
			player.y,
			player.rotation
		);

		setGameState(prev => ({
			...prev,
			projectiles: [...prev.projectiles, projectile]
		}));
	}, []);

	/**
	 * Process touch inputs. Determines player & projectile angle.
	 */
	const handleTouch = useCallback((touches) => {
		// Quit if the game is paused
		if (gameState.paused) return;

		// Determine the touch input statistics
		const start = touches.find(t => t.type === 'start');
		const end = touches.find(t => t.type === 'end');
		const press = touches.find(t => t.type === 'press');
		const touch = touches.find(t => t.type === 'start' || t.type === 'move');

		// Handle firing
		if (start) { // When held down, fire at an interval
			fireIntervalRef.current = setInterval(fireProjectile, 100);
		}
		if (press) { // When pressed, fire once
			fireProjectile();
		}
		// When the touch ends, stop firing
		if (end && fireIntervalRef.current) {
			clearInterval(fireIntervalRef.current);
			fireIntervalRef.current = null;
		}

		// Handle player rotation
		if (touch) {
			const player = playerRef.current;
			// Touch location
			const touchX = touch.event.pageX;
			const touchY = touch.event.pageY;
			// Distance between player & touch
			const dx = touchX - player.x;
			const dy = touchY - player.y;
			// Distance angle, update player rotation
			const angle = Math.atan2(dy, dx) * (180 / Math.PI);
			player.rotation = angle;
		}
	}, [gameState.paused, fireProjectile]);

	/**
	 * Update the game/render state
	 */
	const updateGame = useCallback(() => {
		// Quit if the game is paused
		if (gameState.paused) return;

		// Update the game state on each execution
		setGameState(prev => {
			// Update all entities
			const updatedProjectiles = prev.projectiles.map(p => {
				p.update();
				return p;
			});
			const updatedEnemies = prev.enemies.map(e => {
				e.update();
				return e;
			});

			// Check collisions
			const scoreGained = CollisionDetector.checkProjectileEnemyCollisions(
				updatedProjectiles,
				updatedEnemies
			);

			// Filter active entities
			const { activeProjectiles, activeEnemies } = CollisionDetector.filterActiveEntities(
				updatedProjectiles,
				updatedEnemies,
				SCREEN_WIDTH,
				SCREEN_HEIGHT
			);

			// Check if enemies escaped
			activeEnemies.forEach(e => {
				let outOfBounds = playerRef.current.enemyOutOfBounds(e);

				// The enemy passed the player
				if (outOfBounds) {
					// Apply damage to the player
					playerRef.current.takeDamage(e.getDamage());
					
					// Disable the enemy
					e.active = false;
				}
			});

			// Increment the player's score
			if (playerRef.current) playerRef.current.addScore(scoreGained);

			return {
				...prev,
				projectiles: activeProjectiles,
				enemies: activeEnemies
			};
		});
	}, [gameState.paused]);

	// Pause/Unpause the game
	const togglePause = useCallback(() => {
		setGameState(prev => ({ ...prev, paused: !prev.paused }));
	}, []);

	// Gameplay duration
	const getGameDuration = useCallback(() => {
		return Date.now() - startTimeRef.current;
	}, []);

	// Make game-loop data available to components
	return {
		gameState,
		player: playerRef.current,
		handleTouch,
		updateGame,
		togglePause,
		getGameDuration,
		isGameOver: playerRef.current.getHp() <= 0,
	};
}